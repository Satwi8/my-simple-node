{
  "version": 3,
  "sources": ["../../src/getSep/getSep.ts", "../../src/endSepAppend/endSepAppend.ts", "../../src/endSepRemove/endSepRemove.ts", "../../src/startSepAppend/startSepAppend.ts", "../../src/startSepRemove/startSepRemove.ts", "../../src/alwaysSep/alwaysSep.ts", "../../src/basenames/basenames.ts", "../../src/exists/exists.ts", "../../src/existsSync/existsSync.ts", "../../src/getDirname/getDirname.ts", "../../src/getDirnameSync/getDirnameSync.ts", "../../src/isDescendant/isDescendant.ts", "../../src/isDirectory/isDirectory.ts", "../../src/isDirectorySync/isDirectorySync.ts", "../../src/isEmptyDir/isEmptyDir.ts", "../../src/isEmptyDirSync/isEmptyDirSync.ts", "../../src/replaceSepToPosix/replaceSepToPosix.ts", "../../src/replaceSepToWin32/replaceSepToWin32.ts", "../../src/win32DriveLetterUpdown/win32DriveLetterUpdown.ts"],
  "sourcesContent": ["import path from 'node:path';\n\nexport function getSep() {\n  return path.sep;\n}\n", "import { getSep } from '#/getSep/getSep';\n\nexport function endSepAppend(targetPath: string, sep?: string): string {\n  const nonNullableSep = sep ?? getSep();\n\n  if (targetPath.endsWith(nonNullableSep)) {\n    return targetPath;\n  }\n\n  return `${targetPath}${nonNullableSep}`;\n}\n", "import { getSep } from '#/getSep/getSep';\n\nexport function endSepRemove(targetPath: string, sep?: string): string {\n  const nonNullableSep = sep ?? getSep();\n\n  if (targetPath.endsWith(nonNullableSep)) {\n    return targetPath.substring(0, targetPath.length - 1);\n  }\n\n  return targetPath;\n}\n", "import { getSep } from '#/getSep/getSep';\n\nexport function startSepAppend(targetPath: string, sep?: string): string {\n  const nonNullableSep = sep ?? getSep();\n\n  if (targetPath.startsWith(nonNullableSep)) {\n    return targetPath;\n  }\n\n  return `${nonNullableSep}${targetPath}`;\n}\n", "import { getSep } from '#/getSep/getSep';\n\nexport function startSepRemove(targetPath: string, sep?: string): string {\n  const nonNullableSep = sep ?? getSep();\n\n  if (targetPath.startsWith(nonNullableSep)) {\n    return targetPath.substring(1, targetPath.length);\n  }\n\n  return targetPath;\n}\n", "import { endSepAppend } from '#/endSepAppend/endSepAppend';\nimport { endSepRemove } from '#/endSepRemove/endSepRemove';\nimport { startSepAppend } from '#/startSepAppend/startSepAppend';\nimport { startSepRemove } from '#/startSepRemove/startSepRemove';\n\nexport function alwaysSep(\n  targetPath: string,\n  options: {\n    type: 'start_sep_remove' | 'start_sep_append' | 'end_sep_remove' | 'end_sep_append';\n    sep?: string;\n  },\n): string {\n  try {\n    if (options.type === 'start_sep_remove') {\n      return startSepRemove(targetPath, options.sep);\n    }\n\n    if (options.type === 'start_sep_append') {\n      return startSepAppend(targetPath, options.sep);\n    }\n\n    if (options.type === 'end_sep_remove') {\n      return endSepRemove(targetPath, options.sep);\n    }\n\n    return endSepAppend(targetPath, options.sep);\n  } catch {\n    return targetPath;\n  }\n}\n", "import * as path from 'node:path';\n\nexport function basenames(filename: string, suffix?: string | string[]): string {\n  const base = path.basename(filename);\n\n  if (suffix == null) {\n    return base;\n  }\n\n  const ext = path.extname(filename);\n  const finded = (Array.isArray(suffix) ? suffix : [suffix]).find((s) => s === ext);\n\n  return finded == null ? base : path.basename(filename, ext);\n}\n", "import { isEmpty } from 'my-easy-fp';\nimport fs from 'node:fs';\n\n/**\n * check file existing, if file exists return true, don't exists return false\n * @param filePath - filename with path\n */\nexport async function exists(filePath: string): Promise<boolean> {\n  try {\n    const accessed = await fs.promises.access(filePath);\n    return isEmpty(accessed);\n  } catch (err) {\n    return false;\n  }\n}\n", "import fs from 'node:fs';\n\n/**\n * check file existing, if file exists return true, don't exists return false\n * @param filePath - filename with path\n */\nexport function existsSync(filePath: string): boolean {\n  try {\n    fs.accessSync(filePath);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n", "import { exists } from '#/exists/exists';\nimport { isError, isFalse } from 'my-easy-fp';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\n/**\n * return directory name without filename. If target path is directory name that return same name but\n * target path is file name that return directory name.\n *\n * @param filePath - target path\n * @returns directory name\n */\nexport async function getDirname(filePath: string): Promise<string> {\n  try {\n    const filePathExists = await exists(filePath);\n\n    if (isFalse(filePathExists)) {\n      return path.dirname(filePath);\n    }\n\n    const lstat = await fs.promises.lstat(filePath);\n\n    if (lstat.isDirectory()) {\n      return filePath;\n    }\n\n    const dirname = path.dirname(filePath);\n\n    return dirname;\n  } catch (caught) {\n    const err = isError(caught, new Error(`unknown error from dirname: ${filePath}`));\n\n    throw err;\n  }\n}\n", "import { existsSync } from '#/existsSync/existsSync';\nimport { isError, isFalse } from 'my-easy-fp';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\n/**\n * return directory name without filename. If target path is directory name that return same name but\n * target path is file name that return directory name.\n *\n * Synchronous version of getDirname\n *\n * @param filePath - target path\n * @returns directory name\n */\nexport function getDirnameSync(filePath: string): string {\n  try {\n    const filePathExists = existsSync(filePath);\n\n    if (isFalse(filePathExists)) {\n      return path.dirname(filePath);\n    }\n\n    const lstat = fs.lstatSync(filePath);\n\n    if (lstat.isDirectory()) {\n      return filePath;\n    }\n\n    const dirname = path.dirname(filePath);\n\n    return dirname;\n  } catch (caught) {\n    const err = isError(caught, new Error(`unknown error from dirname: ${filePath}`));\n\n    throw err;\n  }\n}\n", "import { getSep } from '#/getSep/getSep';\n\n/**\n * check target directory is descendant of parent directory\n *\n * @param parentDirPath parent directory path\n * @param targetDirPath child directory path\n * @returns if return true child directory is descendant of parent directory\n */\nexport function isDescendant(parentDirPath: string, targetDirPath: string, sep?: string): boolean {\n  const parentDirPathTokens = parentDirPath.split(sep ?? getSep());\n  const targetDirPathTokens = targetDirPath.split(sep ?? getSep());\n  return parentDirPathTokens.every((token, index) => targetDirPathTokens[index] === token);\n}\n", "import { exists } from '#/exists/exists';\nimport { isFalse } from 'my-easy-fp';\nimport fs from 'node:fs';\n\n/**\n * check target is directory\n *\n * @param filePath - target file path\n * @returns\n */\nexport async function isDirectory(filePath: string): Promise<boolean> {\n  try {\n    const filePathExists = await exists(filePath);\n\n    if (isFalse(filePathExists)) {\n      return false;\n    }\n\n    const lstat = await fs.promises.lstat(filePath);\n\n    return lstat.isDirectory();\n  } catch {\n    return false;\n  }\n}\n", "import { existsSync } from '#/existsSync/existsSync';\nimport { isFalse } from 'my-easy-fp';\nimport fs from 'node:fs';\n\n/**\n * check target is directory synchronous\n *\n * @param filePath target file path\n * @returns\n */\nexport function isDirectorySync(filePath: string): boolean {\n  try {\n    const filePathExists = existsSync(filePath);\n\n    if (isFalse(filePathExists)) {\n      return false;\n    }\n\n    const lstat = fs.lstatSync(filePath);\n\n    return lstat.isDirectory();\n  } catch {\n    return false;\n  }\n}\n", "import { isError } from 'my-easy-fp';\nimport fs from 'node:fs';\n\n/**\n * check directory is empty\n *\n * @param filePath - target file path\n * @param type - can set directory element type: file only file count, type: directyory: only, not pass count all\n * @returns if return true that direcory empty\n */\nexport async function isEmptyDir(filePath: string, type?: 'directory' | 'file'): Promise<boolean> {\n  try {\n    if (type === 'directory') {\n      const children = await fs.promises.readdir(filePath, { withFileTypes: true });\n      return children.filter((child) => child.isDirectory()).length <= 0;\n    }\n\n    if (type === 'file') {\n      const children = await fs.promises.readdir(filePath, { withFileTypes: true });\n      return children.filter((child) => child.isFile()).length <= 0;\n    }\n\n    const children = await fs.promises.readdir(filePath);\n    return children.length <= 0;\n  } catch (caught) {\n    const err = isError(caught, new Error(`unknown error from filepath: ${filePath}`));\n    throw err;\n  }\n}\n", "import { isError } from 'my-easy-fp';\nimport fs from 'node:fs';\n\n/**\n * check directory is empty synchronous\n *\n * @param filePath - target file path\n * @param type  can set directory element type: file only file count, type: directyory: only, not pass count all\n * @returns if return true that direcory empty\n */\nexport function isEmptyDirSync(filePath: string, type?: 'directory' | 'file'): boolean {\n  try {\n    if (type === 'directory') {\n      const children = fs.readdirSync(filePath, { withFileTypes: true });\n      return children.filter((child) => child.isDirectory()).length <= 0;\n    }\n\n    if (type === 'file') {\n      const children = fs.readdirSync(filePath, { withFileTypes: true });\n      return children.filter((child) => child.isFile()).length <= 0;\n    }\n\n    const children = fs.readdirSync(filePath);\n    return children.length <= 0;\n  } catch (caught) {\n    const err = isError(caught, new Error(`unknown error from filepath: ${filePath}`));\n    throw err;\n  }\n}\n", "import { getSep } from '#/getSep/getSep';\nimport path from 'node:path';\n\nexport function replaceSepToPosix(targetPath: string): string {\n  const sep = getSep();\n\n  if (targetPath === '') {\n    return targetPath;\n  }\n\n  if (targetPath.trim() === '.') {\n    return targetPath.trim();\n  }\n\n  if (targetPath.trim() === '..') {\n    return targetPath.trim();\n  }\n\n  if (sep !== path.posix.sep) {\n    const replaced = path.posix.join(...targetPath.split(sep));\n\n    if (targetPath.startsWith(sep)) {\n      return `${path.posix.sep}${replaced}`;\n    }\n\n    if (targetPath.startsWith('..') && !replaced.startsWith(sep)) {\n      return replaced;\n    }\n\n    if (targetPath.startsWith('.') && !replaced.startsWith(sep)) {\n      return ['.', replaced].join(path.posix.sep);\n    }\n\n    return replaced;\n  }\n\n  return targetPath;\n}\n", "import { getSep } from '#/getSep/getSep';\nimport path from 'node:path';\n\nexport function replaceSepToWin32(targetPath: string): string {\n  const sep = getSep();\n\n  if (targetPath === '') {\n    return targetPath;\n  }\n\n  if (targetPath.trim() === '.') {\n    return targetPath.trim();\n  }\n\n  if (targetPath.trim() === '..') {\n    return targetPath.trim();\n  }\n\n  if (sep !== path.win32.sep) {\n    const replaced = path.win32.join(...targetPath.split(sep));\n\n    if (targetPath.startsWith(sep)) {\n      return `${path.win32.sep}${replaced}`;\n    }\n\n    if (targetPath.startsWith('..') && !replaced.startsWith(sep)) {\n      return replaced;\n    }\n\n    if (targetPath.startsWith('.') && !replaced.startsWith(sep)) {\n      return ['.', replaced].join(path.win32.sep);\n    }\n\n    return replaced;\n  }\n\n  return targetPath;\n}\n", "import os from 'node:os';\nimport path from 'node:path';\n\nexport function win32DriveLetterUpdown(targetPath: string, type?: 'upper' | 'lower') {\n  if (os.platform() === 'win32') {\n    const matched = /^([a-zA-Z]:)(.*)$/.exec(targetPath.trim());\n\n    if (matched === null || matched === undefined) {\n      return targetPath;\n    }\n\n    const [, driveChar, ...otherPath] = matched;\n\n    /* c8 ignore start */\n    if (driveChar == null) {\n      return targetPath;\n    }\n    /* c8 ignore stop */\n\n    return path.join(\n      (type ?? 'upper') === 'upper' ? driveChar.toUpperCase() : driveChar.toLowerCase(),\n      otherPath.join(''),\n    );\n  }\n\n  return targetPath;\n}\n"],
  "mappings": "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",
  "names": ["path", "fs", "fs", "path", "dirname", "isError", "isFalse", "fs", "path", "dirname", "isFalse", "fs", "isFalse", "fs", "isError", "fs", "children", "isError", "fs", "children", "path", "path", "path"]
}
