// src/getSep/getSep.ts
import path from "path";
function getSep() {
  return path.sep;
}

// src/endSepAppend/endSepAppend.ts
function endSepAppend(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.endsWith(nonNullableSep)) {
    return targetPath;
  }
  return `${targetPath}${nonNullableSep}`;
}

// src/endSepRemove/endSepRemove.ts
function endSepRemove(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.endsWith(nonNullableSep)) {
    return targetPath.substring(0, targetPath.length - 1);
  }
  return targetPath;
}

// src/startSepAppend/startSepAppend.ts
function startSepAppend(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.startsWith(nonNullableSep)) {
    return targetPath;
  }
  return `${nonNullableSep}${targetPath}`;
}

// src/startSepRemove/startSepRemove.ts
function startSepRemove(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.startsWith(nonNullableSep)) {
    return targetPath.substring(1, targetPath.length);
  }
  return targetPath;
}

// src/alwaysSep/alwaysSep.ts
function alwaysSep(targetPath, options) {
  try {
    if (options.type === "start_sep_remove") {
      return startSepRemove(targetPath, options.sep);
    }
    if (options.type === "start_sep_append") {
      return startSepAppend(targetPath, options.sep);
    }
    if (options.type === "end_sep_remove") {
      return endSepRemove(targetPath, options.sep);
    }
    return endSepAppend(targetPath, options.sep);
  } catch {
    return targetPath;
  }
}

// src/basenames/basenames.ts
import * as path2 from "path";
function basenames(filename, suffix) {
  const base = path2.basename(filename);
  if (suffix == null) {
    return base;
  }
  const ext = path2.extname(filename);
  const finded = (Array.isArray(suffix) ? suffix : [suffix]).find((s) => s === ext);
  return finded == null ? base : path2.basename(filename, ext);
}

// src/exists/exists.ts
import { isEmpty } from "my-easy-fp";
import fs from "fs";
async function exists(filePath) {
  try {
    const accessed = await fs.promises.access(filePath);
    return isEmpty(accessed);
  } catch (err) {
    return false;
  }
}

// src/existsSync/existsSync.ts
import fs2 from "fs";
function existsSync(filePath) {
  try {
    fs2.accessSync(filePath);
    return true;
  } catch (err) {
    return false;
  }
}

// src/getDirname/getDirname.ts
import { isError, isFalse } from "my-easy-fp";
import * as fs3 from "fs";
import * as path3 from "path";
async function getDirname(filePath) {
  try {
    const filePathExists = await exists(filePath);
    if (isFalse(filePathExists)) {
      return path3.dirname(filePath);
    }
    const lstat = await fs3.promises.lstat(filePath);
    if (lstat.isDirectory()) {
      return filePath;
    }
    const dirname3 = path3.dirname(filePath);
    return dirname3;
  } catch (caught) {
    const err = isError(caught, new Error(`unknown error from dirname: ${filePath}`));
    throw err;
  }
}

// src/getDirnameSync/getDirnameSync.ts
import { isError as isError2, isFalse as isFalse2 } from "my-easy-fp";
import * as fs4 from "fs";
import * as path4 from "path";
function getDirnameSync(filePath) {
  try {
    const filePathExists = existsSync(filePath);
    if (isFalse2(filePathExists)) {
      return path4.dirname(filePath);
    }
    const lstat = fs4.lstatSync(filePath);
    if (lstat.isDirectory()) {
      return filePath;
    }
    const dirname3 = path4.dirname(filePath);
    return dirname3;
  } catch (caught) {
    const err = isError2(caught, new Error(`unknown error from dirname: ${filePath}`));
    throw err;
  }
}

// src/isDescendant/isDescendant.ts
function isDescendant(parentDirPath, targetDirPath, sep) {
  const parentDirPathTokens = parentDirPath.split(sep ?? getSep());
  const targetDirPathTokens = targetDirPath.split(sep ?? getSep());
  return parentDirPathTokens.every((token, index) => targetDirPathTokens[index] === token);
}

// src/isDirectory/isDirectory.ts
import { isFalse as isFalse3 } from "my-easy-fp";
import fs5 from "fs";
async function isDirectory(filePath) {
  try {
    const filePathExists = await exists(filePath);
    if (isFalse3(filePathExists)) {
      return false;
    }
    const lstat = await fs5.promises.lstat(filePath);
    return lstat.isDirectory();
  } catch {
    return false;
  }
}

// src/isDirectorySync/isDirectorySync.ts
import { isFalse as isFalse4 } from "my-easy-fp";
import fs6 from "fs";
function isDirectorySync(filePath) {
  try {
    const filePathExists = existsSync(filePath);
    if (isFalse4(filePathExists)) {
      return false;
    }
    const lstat = fs6.lstatSync(filePath);
    return lstat.isDirectory();
  } catch {
    return false;
  }
}

// src/isEmptyDir/isEmptyDir.ts
import { isError as isError3 } from "my-easy-fp";
import fs7 from "fs";
async function isEmptyDir(filePath, type) {
  try {
    if (type === "directory") {
      const children2 = await fs7.promises.readdir(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isDirectory()).length <= 0;
    }
    if (type === "file") {
      const children2 = await fs7.promises.readdir(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isFile()).length <= 0;
    }
    const children = await fs7.promises.readdir(filePath);
    return children.length <= 0;
  } catch (caught) {
    const err = isError3(caught, new Error(`unknown error from filepath: ${filePath}`));
    throw err;
  }
}

// src/isEmptyDirSync/isEmptyDirSync.ts
import { isError as isError4 } from "my-easy-fp";
import fs8 from "fs";
function isEmptyDirSync(filePath, type) {
  try {
    if (type === "directory") {
      const children2 = fs8.readdirSync(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isDirectory()).length <= 0;
    }
    if (type === "file") {
      const children2 = fs8.readdirSync(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isFile()).length <= 0;
    }
    const children = fs8.readdirSync(filePath);
    return children.length <= 0;
  } catch (caught) {
    const err = isError4(caught, new Error(`unknown error from filepath: ${filePath}`));
    throw err;
  }
}

// src/replaceSepToPosix/replaceSepToPosix.ts
import path5 from "path";
function replaceSepToPosix(targetPath) {
  const sep = getSep();
  if (targetPath === "") {
    return targetPath;
  }
  if (targetPath.trim() === ".") {
    return targetPath.trim();
  }
  if (targetPath.trim() === "..") {
    return targetPath.trim();
  }
  if (sep !== path5.posix.sep) {
    const replaced = path5.posix.join(...targetPath.split(sep));
    if (targetPath.startsWith(sep)) {
      return `${path5.posix.sep}${replaced}`;
    }
    if (targetPath.startsWith("..") && !replaced.startsWith(sep)) {
      return replaced;
    }
    if (targetPath.startsWith(".") && !replaced.startsWith(sep)) {
      return [".", replaced].join(path5.posix.sep);
    }
    return replaced;
  }
  return targetPath;
}

// src/replaceSepToWin32/replaceSepToWin32.ts
import path6 from "path";
function replaceSepToWin32(targetPath) {
  const sep = getSep();
  if (targetPath === "") {
    return targetPath;
  }
  if (targetPath.trim() === ".") {
    return targetPath.trim();
  }
  if (targetPath.trim() === "..") {
    return targetPath.trim();
  }
  if (sep !== path6.win32.sep) {
    const replaced = path6.win32.join(...targetPath.split(sep));
    if (targetPath.startsWith(sep)) {
      return `${path6.win32.sep}${replaced}`;
    }
    if (targetPath.startsWith("..") && !replaced.startsWith(sep)) {
      return replaced;
    }
    if (targetPath.startsWith(".") && !replaced.startsWith(sep)) {
      return [".", replaced].join(path6.win32.sep);
    }
    return replaced;
  }
  return targetPath;
}

// src/win32DriveLetterUpdown/win32DriveLetterUpdown.ts
import os from "os";
import path7 from "path";
function win32DriveLetterUpdown(targetPath, type) {
  if (os.platform() === "win32") {
    const matched = /^([a-zA-Z]:)(.*)$/.exec(targetPath.trim());
    if (matched === null || matched === void 0) {
      return targetPath;
    }
    const [, driveChar, ...otherPath] = matched;
    if (driveChar == null) {
      return targetPath;
    }
    return path7.join(
      (type ?? "upper") === "upper" ? driveChar.toUpperCase() : driveChar.toLowerCase(),
      otherPath.join("")
    );
  }
  return targetPath;
}
export {
  alwaysSep,
  basenames,
  endSepAppend,
  endSepRemove,
  exists,
  existsSync,
  getDirname,
  getDirnameSync,
  getSep,
  isDescendant,
  isDirectory,
  isDirectorySync,
  isEmptyDir,
  isEmptyDirSync,
  replaceSepToPosix,
  replaceSepToWin32,
  startSepAppend,
  startSepRemove,
  win32DriveLetterUpdown
};
//# sourceMappingURL=index.mjs.map
