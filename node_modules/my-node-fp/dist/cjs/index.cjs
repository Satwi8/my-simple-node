"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  alwaysSep: () => alwaysSep,
  basenames: () => basenames,
  endSepAppend: () => endSepAppend,
  endSepRemove: () => endSepRemove,
  exists: () => exists,
  existsSync: () => existsSync,
  getDirname: () => getDirname,
  getDirnameSync: () => getDirnameSync,
  getSep: () => getSep,
  isDescendant: () => isDescendant,
  isDirectory: () => isDirectory,
  isDirectorySync: () => isDirectorySync,
  isEmptyDir: () => isEmptyDir,
  isEmptyDirSync: () => isEmptyDirSync,
  replaceSepToPosix: () => replaceSepToPosix,
  replaceSepToWin32: () => replaceSepToWin32,
  startSepAppend: () => startSepAppend,
  startSepRemove: () => startSepRemove,
  win32DriveLetterUpdown: () => win32DriveLetterUpdown
});
module.exports = __toCommonJS(src_exports);

// src/getSep/getSep.ts
var import_node_path = __toESM(require("path"));
function getSep() {
  return import_node_path.default.sep;
}

// src/endSepAppend/endSepAppend.ts
function endSepAppend(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.endsWith(nonNullableSep)) {
    return targetPath;
  }
  return `${targetPath}${nonNullableSep}`;
}

// src/endSepRemove/endSepRemove.ts
function endSepRemove(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.endsWith(nonNullableSep)) {
    return targetPath.substring(0, targetPath.length - 1);
  }
  return targetPath;
}

// src/startSepAppend/startSepAppend.ts
function startSepAppend(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.startsWith(nonNullableSep)) {
    return targetPath;
  }
  return `${nonNullableSep}${targetPath}`;
}

// src/startSepRemove/startSepRemove.ts
function startSepRemove(targetPath, sep) {
  const nonNullableSep = sep ?? getSep();
  if (targetPath.startsWith(nonNullableSep)) {
    return targetPath.substring(1, targetPath.length);
  }
  return targetPath;
}

// src/alwaysSep/alwaysSep.ts
function alwaysSep(targetPath, options) {
  try {
    if (options.type === "start_sep_remove") {
      return startSepRemove(targetPath, options.sep);
    }
    if (options.type === "start_sep_append") {
      return startSepAppend(targetPath, options.sep);
    }
    if (options.type === "end_sep_remove") {
      return endSepRemove(targetPath, options.sep);
    }
    return endSepAppend(targetPath, options.sep);
  } catch {
    return targetPath;
  }
}

// src/basenames/basenames.ts
var path2 = __toESM(require("path"));
function basenames(filename, suffix) {
  const base = path2.basename(filename);
  if (suffix == null) {
    return base;
  }
  const ext = path2.extname(filename);
  const finded = (Array.isArray(suffix) ? suffix : [suffix]).find((s) => s === ext);
  return finded == null ? base : path2.basename(filename, ext);
}

// src/exists/exists.ts
var import_my_easy_fp = require("my-easy-fp");
var import_node_fs = __toESM(require("fs"));
async function exists(filePath) {
  try {
    const accessed = await import_node_fs.default.promises.access(filePath);
    return (0, import_my_easy_fp.isEmpty)(accessed);
  } catch (err) {
    return false;
  }
}

// src/existsSync/existsSync.ts
var import_node_fs2 = __toESM(require("fs"));
function existsSync(filePath) {
  try {
    import_node_fs2.default.accessSync(filePath);
    return true;
  } catch (err) {
    return false;
  }
}

// src/getDirname/getDirname.ts
var import_my_easy_fp2 = require("my-easy-fp");
var fs3 = __toESM(require("fs"));
var path3 = __toESM(require("path"));
async function getDirname(filePath) {
  try {
    const filePathExists = await exists(filePath);
    if ((0, import_my_easy_fp2.isFalse)(filePathExists)) {
      return path3.dirname(filePath);
    }
    const lstat = await fs3.promises.lstat(filePath);
    if (lstat.isDirectory()) {
      return filePath;
    }
    const dirname3 = path3.dirname(filePath);
    return dirname3;
  } catch (caught) {
    const err = (0, import_my_easy_fp2.isError)(caught, new Error(`unknown error from dirname: ${filePath}`));
    throw err;
  }
}

// src/getDirnameSync/getDirnameSync.ts
var import_my_easy_fp3 = require("my-easy-fp");
var fs4 = __toESM(require("fs"));
var path4 = __toESM(require("path"));
function getDirnameSync(filePath) {
  try {
    const filePathExists = existsSync(filePath);
    if ((0, import_my_easy_fp3.isFalse)(filePathExists)) {
      return path4.dirname(filePath);
    }
    const lstat = fs4.lstatSync(filePath);
    if (lstat.isDirectory()) {
      return filePath;
    }
    const dirname3 = path4.dirname(filePath);
    return dirname3;
  } catch (caught) {
    const err = (0, import_my_easy_fp3.isError)(caught, new Error(`unknown error from dirname: ${filePath}`));
    throw err;
  }
}

// src/isDescendant/isDescendant.ts
function isDescendant(parentDirPath, targetDirPath, sep) {
  const parentDirPathTokens = parentDirPath.split(sep ?? getSep());
  const targetDirPathTokens = targetDirPath.split(sep ?? getSep());
  return parentDirPathTokens.every((token, index) => targetDirPathTokens[index] === token);
}

// src/isDirectory/isDirectory.ts
var import_my_easy_fp4 = require("my-easy-fp");
var import_node_fs3 = __toESM(require("fs"));
async function isDirectory(filePath) {
  try {
    const filePathExists = await exists(filePath);
    if ((0, import_my_easy_fp4.isFalse)(filePathExists)) {
      return false;
    }
    const lstat = await import_node_fs3.default.promises.lstat(filePath);
    return lstat.isDirectory();
  } catch {
    return false;
  }
}

// src/isDirectorySync/isDirectorySync.ts
var import_my_easy_fp5 = require("my-easy-fp");
var import_node_fs4 = __toESM(require("fs"));
function isDirectorySync(filePath) {
  try {
    const filePathExists = existsSync(filePath);
    if ((0, import_my_easy_fp5.isFalse)(filePathExists)) {
      return false;
    }
    const lstat = import_node_fs4.default.lstatSync(filePath);
    return lstat.isDirectory();
  } catch {
    return false;
  }
}

// src/isEmptyDir/isEmptyDir.ts
var import_my_easy_fp6 = require("my-easy-fp");
var import_node_fs5 = __toESM(require("fs"));
async function isEmptyDir(filePath, type) {
  try {
    if (type === "directory") {
      const children2 = await import_node_fs5.default.promises.readdir(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isDirectory()).length <= 0;
    }
    if (type === "file") {
      const children2 = await import_node_fs5.default.promises.readdir(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isFile()).length <= 0;
    }
    const children = await import_node_fs5.default.promises.readdir(filePath);
    return children.length <= 0;
  } catch (caught) {
    const err = (0, import_my_easy_fp6.isError)(caught, new Error(`unknown error from filepath: ${filePath}`));
    throw err;
  }
}

// src/isEmptyDirSync/isEmptyDirSync.ts
var import_my_easy_fp7 = require("my-easy-fp");
var import_node_fs6 = __toESM(require("fs"));
function isEmptyDirSync(filePath, type) {
  try {
    if (type === "directory") {
      const children2 = import_node_fs6.default.readdirSync(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isDirectory()).length <= 0;
    }
    if (type === "file") {
      const children2 = import_node_fs6.default.readdirSync(filePath, { withFileTypes: true });
      return children2.filter((child) => child.isFile()).length <= 0;
    }
    const children = import_node_fs6.default.readdirSync(filePath);
    return children.length <= 0;
  } catch (caught) {
    const err = (0, import_my_easy_fp7.isError)(caught, new Error(`unknown error from filepath: ${filePath}`));
    throw err;
  }
}

// src/replaceSepToPosix/replaceSepToPosix.ts
var import_node_path2 = __toESM(require("path"));
function replaceSepToPosix(targetPath) {
  const sep = getSep();
  if (targetPath === "") {
    return targetPath;
  }
  if (targetPath.trim() === ".") {
    return targetPath.trim();
  }
  if (targetPath.trim() === "..") {
    return targetPath.trim();
  }
  if (sep !== import_node_path2.default.posix.sep) {
    const replaced = import_node_path2.default.posix.join(...targetPath.split(sep));
    if (targetPath.startsWith(sep)) {
      return `${import_node_path2.default.posix.sep}${replaced}`;
    }
    if (targetPath.startsWith("..") && !replaced.startsWith(sep)) {
      return replaced;
    }
    if (targetPath.startsWith(".") && !replaced.startsWith(sep)) {
      return [".", replaced].join(import_node_path2.default.posix.sep);
    }
    return replaced;
  }
  return targetPath;
}

// src/replaceSepToWin32/replaceSepToWin32.ts
var import_node_path3 = __toESM(require("path"));
function replaceSepToWin32(targetPath) {
  const sep = getSep();
  if (targetPath === "") {
    return targetPath;
  }
  if (targetPath.trim() === ".") {
    return targetPath.trim();
  }
  if (targetPath.trim() === "..") {
    return targetPath.trim();
  }
  if (sep !== import_node_path3.default.win32.sep) {
    const replaced = import_node_path3.default.win32.join(...targetPath.split(sep));
    if (targetPath.startsWith(sep)) {
      return `${import_node_path3.default.win32.sep}${replaced}`;
    }
    if (targetPath.startsWith("..") && !replaced.startsWith(sep)) {
      return replaced;
    }
    if (targetPath.startsWith(".") && !replaced.startsWith(sep)) {
      return [".", replaced].join(import_node_path3.default.win32.sep);
    }
    return replaced;
  }
  return targetPath;
}

// src/win32DriveLetterUpdown/win32DriveLetterUpdown.ts
var import_node_os = __toESM(require("os"));
var import_node_path4 = __toESM(require("path"));
function win32DriveLetterUpdown(targetPath, type) {
  if (import_node_os.default.platform() === "win32") {
    const matched = /^([a-zA-Z]:)(.*)$/.exec(targetPath.trim());
    if (matched === null || matched === void 0) {
      return targetPath;
    }
    const [, driveChar, ...otherPath] = matched;
    if (driveChar == null) {
      return targetPath;
    }
    return import_node_path4.default.join(
      (type ?? "upper") === "upper" ? driveChar.toUpperCase() : driveChar.toLowerCase(),
      otherPath.join("")
    );
  }
  return targetPath;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  alwaysSep,
  basenames,
  endSepAppend,
  endSepRemove,
  exists,
  existsSync,
  getDirname,
  getDirnameSync,
  getSep,
  isDescendant,
  isDirectory,
  isDirectorySync,
  isEmptyDir,
  isEmptyDirSync,
  replaceSepToPosix,
  replaceSepToWin32,
  startSepAppend,
  startSepRemove,
  win32DriveLetterUpdown
});
//# sourceMappingURL=index.cjs.map
